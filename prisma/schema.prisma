generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model device {
  id            Int                @id @default(autoincrement())
  userId        Int
  userAgent     String             @db.Text
  deviceType    device_deviceType? @default(unknown)
  firstSeenAt   DateTime?          @default(now()) @db.DateTime(0)
  lastSeenAt    DateTime?          @default(now()) @db.DateTime(0)
  user          user               @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "device_ibfk_1")
  refresh_token refresh_token[]

  @@index([userId], map: "userId")
}

model match {
  id           Int            @id @default(autoincrement())
  status       match_status
  createdAt    DateTime?      @default(now()) @db.DateTime(0)
  winnerId     Int?
  turn         Int            @default(1)
  user         user?          @relation(fields: [winnerId], references: [id], onUpdate: NoAction, map: "match_ibfk_1")
  match_move   match_move[]
  match_piece  match_piece[]
  match_player match_player[]

  @@index([winnerId], map: "match_ibfk_1")
}

model match_move {
  id                 Int       @id @default(autoincrement())
  matchId            Int
  playerId           Int?
  moveNumber         Int
  fromX              Int       @db.TinyInt
  fromY              Int       @db.TinyInt
  toX                Int       @db.TinyInt
  toY                Int       @db.TinyInt
  pieceType          String    @db.VarChar(50)
  capturedPieceType  String?   @db.VarChar(50)
  specialAbilityUsed Int?      @default(0) @db.TinyInt
  createdAt          DateTime? @default(now()) @db.DateTime(0)
  match              match     @relation(fields: [matchId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "match_move_ibfk_1")
  user               user?     @relation(fields: [playerId], references: [id], onUpdate: NoAction, map: "match_move_ibfk_2")

  @@index([matchId], map: "matchId")
  @@index([playerId], map: "playerId")
}

model match_piece {
  id          Int              @id @default(autoincrement())
  matchId     Int
  playerId    Int?
  type        match_piece_type
  posX        Int?             @db.TinyInt
  posY        Int?             @db.TinyInt
  usedAbility Int?             @default(0) @db.TinyInt
  captured    Int?             @default(0) @db.TinyInt
  status      Json?
  match       match            @relation(fields: [matchId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "match_piece_ibfk_1")
  user        user?            @relation(fields: [playerId], references: [id], onUpdate: NoAction, map: "match_piece_ibfk_2")

  @@index([matchId], map: "matchId")
  @@index([playerId], map: "playerId")
}

model match_player {
  id          Int                @id @default(autoincrement())
  userId      Int?
  matchId     Int
  color       match_player_color
  dreamEnergy Int                @default(20)
  user        user?              @relation(fields: [userId], references: [id], onUpdate: NoAction, map: "match_player_ibfk_1")
  match       match              @relation(fields: [matchId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "match_player_ibfk_2")

  @@index([matchId], map: "matchId")
  @@index([userId], map: "userId")
}

model refresh_token {
  id        Int       @id @default(autoincrement())
  userId    Int
  deviceId  Int
  token     String?   @unique(map: "token") @db.VarChar(255)
  ipAddress String?   @db.VarChar(45)
  country   String?   @db.VarChar(100)
  region    String?   @db.VarChar(100)
  createdAt DateTime? @default(now()) @db.DateTime(0)
  expiresAt DateTime? @db.DateTime(0)
  user      user      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "refresh_token_ibfk_1")
  device    device    @relation(fields: [deviceId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "refresh_token_ibfk_2")

  @@index([deviceId], map: "deviceId")
  @@index([userId], map: "userId")
}

model user {
  id                     Int              @id @default(autoincrement())
  email                  String?          @unique(map: "email") @db.VarChar(255)
  username               String           @unique(map: "username") @db.VarChar(25)
  passwordHash           String           @db.Text
  isEmailVerified        Boolean?         @default(false)
  createdAt              DateTime?        @default(now()) @db.DateTime(0)
  updatedAt              DateTime?        @default(now()) @db.DateTime(0)
  device                 device[]
  friendRequestsSent     friend_request[] @relation("fromUser")
  friendRequestsReceived friend_request[] @relation("toUser")
  friendshipsA           friendship[]     @relation("userA")
  friendshipsB           friendship[]     @relation("userB")
  challengesSent         friend_challenge[] @relation("challenge_fromUser")
  challengesReceived     friend_challenge[] @relation("challenge_toUser")
  match                  match[]
  match_move             match_move[]
  match_piece            match_piece[]
  match_player           match_player[]
  match_queue            match_queue?
  refresh_token          refresh_token[]
}

model friend_request {
  id         Int                   @id @default(autoincrement())
  fromUserId Int
  toUserId   Int
  status     friend_request_status @default(PENDING)
  createdAt  DateTime?             @default(now()) @db.DateTime(0)
  updatedAt  DateTime?             @default(now()) @db.DateTime(0)
  fromUser   user                  @relation("fromUser", fields: [fromUserId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friend_request_from_fk")
  toUser     user                  @relation("toUser", fields: [toUserId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friend_request_to_fk")

  @@unique([fromUserId, toUserId], map: "unique_request_pair")
  @@index([toUserId], map: "toUserId")
  @@index([fromUserId], map: "fromUserId")
}

model friendship {
  id        Int       @id @default(autoincrement())
  userAId   Int
  userBId   Int
  createdAt DateTime? @default(now()) @db.DateTime(0)
  userA     user      @relation("userA", fields: [userAId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friendship_userA_fk")
  userB     user      @relation("userB", fields: [userBId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friendship_userB_fk")

  @@unique([userAId, userBId], map: "unique_friendship_ordered")
  @@index([userBId], map: "userBId")
  @@index([userAId], map: "userAId")
}

model match_queue {
  id       Int                @id @default(autoincrement())
  userId   Int                @unique(map: "userId")
  status   match_queue_status @default(WAITING)
  joinedAt DateTime?          @default(now()) @db.DateTime(0)
  user     user               @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "match_queue_ibfk_1")
}

model friend_challenge {
  id         Int                        @id @default(autoincrement())
  fromUserId Int
  toUserId   Int
  status     friend_challenge_status    @default(WAITING)
  createdAt  DateTime?                  @default(now()) @db.DateTime(0)
  updatedAt  DateTime?                  @default(now()) @db.DateTime(0)
  fromUser   user                       @relation("challenge_fromUser", fields: [fromUserId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friend_challenge_from_fk")
  toUser     user                       @relation("challenge_toUser", fields: [toUserId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "friend_challenge_to_fk")

  @@index([fromUserId], map: "fromUserId")
  @@index([toUserId], map: "toUserId")
}

enum friend_request_status {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

enum friend_challenge_status {
  WAITING
  ACCEPTED
  DECLINED
  CANCELLED
  EXPIRED
}

enum match_status {
  ONGOING
  FINISHED
}

enum match_player_color {
  WHITE
  BLACK
}

enum match_piece_type {
  SLEEPLESS_EYE
  PHANTOM_MATRIARCH
  SHADOW_HUNTER
  DOPPELGANGER
  PHOBIC_LEAPER
  PSYCHIC_LARVA
}

enum device_deviceType {
  desktop
  mobile
  tablet
  bot
  unknown
}

enum match_queue_status {
  WAITING
  MATCHED
  CANCELLED
}
